/**
 * Copyright 2016-2025 California Institute of Technology
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "example_ros_connector/connector.h"
#include "example_ros_connector/specific_client.h" 

#include <rclcpp/rclcpp.hpp>
#include <atomic>
#include <memory>

#include <boost/foreach.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/xml_parser.hpp>


TRACE_CONNECTOR(trace::example_ros_connector::Connector,
                "trace_example_ros_connector", "0.0.0");

namespace trace {
namespace example_ros_connector {

Connector::Connector() : Connector("trace_example_ros_connector") {
    // Additional initialization if needed
}

Connector::Connector(const std::string &node_name)
    : Node(node_name){
}

void Connector::initialize() {
  RCLCPP_INFO(this->get_logger(), "Initializing behavior clients...");

  // populate resource_to_client_map with the autogenerated clients 
  // bool ok = this->create_action_clients_from_xml();
  // if (!ok) {
  //   throw std::runtime_error(
  //       "Unable to create action files from XML configuration.");
  // }
  
  // Add hard coded clients here 
  this->resource_to_client_map["determine_average"] =
      std::make_shared<SpecificClient>();
  // if (!ok) {
  //   throw std::runtime_error(
  //       "Unable to create action files from XML configuration.");
  // }

  RCLCPP_INFO(this->get_logger(), "Initializing behavior clients... DONE!");
}

bool Connector::create_action_clients_from_xml() {
  // Get XML filepath using ros param
  // auto filepath_resource_action_list = this->declare_parameter<std::string>("filepath_resource_action_list", "");

  // // Parse XML
  // boost::property_tree::ptree resource_ptree;

  // try {
  //   boost::property_tree::read_xml(filepath_resource_action_list, resource_ptree);
  // } catch (const boost::property_tree::xml_parser::xml_parser_error &e) {
  //   RCLCPP_INFO(this->get_logger(), "Unable to read xml filepath");
  //   return false;
  // }

  // // Create the action client
  // for (const auto &val : resource_ptree.get_child("resource_list")) {
  //   if (val.first == "resource") {
  //     this->resource_to_client_map[val.second.get<std::string>("resource_name")] =
  //         // ::trace::ros_msgs_autocoder::CreateActionClientByType(
  //         //     val.second.get<std::string>("action_type"),
  //         //     val.second.get<std::string>("action_topic"), this);
  //   }
  // }
  return true;
}

bool Connector::check_resource(const std::string &resource_name, const PropertyMap &properties) {
  if (resource_name != "dummy") {
    return (this->resource_to_client_map.find(resource_name) != this->resource_to_client_map.end());
  }
  return true;
}

bool Connector::reserve_resource(const std::string &task_uuid, const std::unordered_map<std::string, std::string> &properties) {
  auto resource_name = properties.at("resource_name");
  this->resource_to_client_map.at(resource_name)->Connect();
  return true;
}

void Connector::release_resource(const std::string &task_uuid, const PropertyMap &properties){
    // No-op for actionlib    
}

void Connector::log(const SeverityLevel level, const std::string &function_name,
                    const std::string &file_name, int line_number, const std::string &msg) {

  std::string log_message = file_name + ":" + std::to_string(line_number) + " in " + function_name + ": " + msg;
  switch (level) {
    case SeverityLevel::DEBUG:
      RCLCPP_DEBUG(this->get_logger(), log_message.c_str());
      break;
    case SeverityLevel::INFO:
      RCLCPP_INFO(this->get_logger(), log_message.c_str());
      break;
    case SeverityLevel::WARNING:
      RCLCPP_WARN(this->get_logger(), log_message.c_str());
      break;
    case SeverityLevel::ERROR:
      RCLCPP_ERROR(this->get_logger(), log_message.c_str());
      break;
    case SeverityLevel::FATAL:
      RCLCPP_FATAL(this->get_logger(), log_message.c_str());
      break;
  }
}

std::chrono::milliseconds Connector::to_connector_time(const std::chrono::milliseconds &duration_ms) {
  return duration_ms;
}

std::shared_future<Outcome> Connector::command_resource(
    const std::string &task_uuid,
    const std::unordered_map<std::string, std::string> &properties) {
  RCLCPP_WARN(this->get_logger(), "About to try to command activity defined in (%s)", task_uuid.c_str());
  auto resource_name = properties.at("resource_name");
  return this->resource_to_client_map.at(resource_name)->SendCommand(task_uuid, properties);
}

void Connector::abort_command(
    const std::string &task_uuid,
    const std::unordered_map<std::string, std::string> &properties) {
  auto resource_name = properties.at("resource_name");
  this->resource_to_client_map.at(resource_name)->AbortCommand(task_uuid);
}

void Connector::timer_callback(std::shared_ptr<rclcpp::TimerBase> timer,
                               std::atomic<bool> *is_timeout,
                               std::condition_variable *timer_interrupt) {
    is_timeout->store(true);
    timer_interrupt->notify_all();
}

bool Connector::wait_for(std::condition_variable &timer_interrupt,
                         std::unique_lock<std::mutex> &timer_lock,
                         const std::chrono::milliseconds &duration_ms) {
  if (duration_ms <= std::chrono::milliseconds::zero()) {
    return true;
  }

  std::atomic<bool> is_timeout(false);
  auto timer = this->create_wall_timer(
    std::chrono::duration_cast<std::chrono::nanoseconds>(duration_ms),
    [this, &is_timeout, &timer_interrupt]() {
      timer_callback(nullptr, &is_timeout, &timer_interrupt);
    });


  timer_interrupt.wait(timer_lock);
  return is_timeout.load();
}


bool Connector::wait_until(
    std::condition_variable &timer_interrupt,
    std::unique_lock<std::mutex> &timer_lock,
    const std::chrono::time_point<std::chrono::system_clock> time_utc) {
  std::atomic<bool> is_interrupted(false);
  auto end_time = std::chrono::system_clock::to_time_t(time_utc);
  auto end_ros_time = rclcpp::Time(end_time);

  // Create a clock
  rclcpp::Clock ros_clock(RCL_SYSTEM_TIME);

  while (rclcpp::ok() && ros_clock.now() < end_ros_time && !is_interrupted.load()) {
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
  }

  if (is_interrupted.load()) {
    return false;
  } else {
    timer_interrupt.notify_all();
    return true;
  }
}

void Connector::destroy() {
  // Clean-up or resource deallocation
}

} // namespace example_ros_connector
} // namespace trace
